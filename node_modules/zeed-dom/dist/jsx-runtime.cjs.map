{"version":3,"sources":["../src/jsx-runtime.ts","../src/h.ts","../src/encoding.ts","../src/html.ts"],"sourcesContent":["import { h } from \"./html\"\n\n// See\n// https://esbuild.github.io/api/#jsx-import-source\n// https://www.typescriptlang.org/tsconfig/#jsxImportSource\n\nexport {\n  //\n  h as jsx,\n  h as jsxs,\n  h as jsxDEV,\n  h,\n}\n","// Copyright (c) 2020 Dirk Holtwick. All rights reserved. https://holtwick.de/copyright\n\nimport { VDocument, VDocumentFragment } from \"./vdom\"\n\n/*\n * Abstraction for h/jsx like DOM descriptions.\n * It is used in DOM, VDOM\n *\n */\n\ninterface Context {\n  h?: any\n  document: VDocument | VDocumentFragment\n}\n\nfunction _h(\n  context: Context,\n  tag: string | ((a0: any) => string),\n  attrs: object,\n  children: any[]\n): string {\n  if (typeof tag === \"function\") {\n    return tag.call(null, {\n      props: { ...attrs, children },\n      attrs,\n      children,\n      h: context.h,\n      context,\n    })\n  } else {\n    let el\n    if (tag) {\n      if (tag.toLowerCase() === \"fragment\") {\n        el = context.document.createDocumentFragment()\n      } else {\n        el = context.document.createElement(tag)\n      }\n    } else {\n      el = context.document.createElement(\"div\")\n    }\n    if (attrs) {\n      for (let [key, value] of Object.entries(attrs)) {\n        key = key.toString()\n        const compareKey = key.toLowerCase()\n        if (compareKey === \"classname\") {\n          el.className = value\n        } else if (compareKey === \"on\") {\n          Object.entries(value).forEach(([name, value]) => {\n            el.setAttribute(\"on\" + name, value)\n          })\n          // else if (key.indexOf('on') === 0) {\n          //   if (el.addEventListener) {\n          //     el.addEventListener(key.substring(2), value)\n          //     continue\n          //   }\n        } else if (value !== false && value != null) {\n          if (value === true) {\n            el.setAttribute(key, key)\n          } else {\n            el.setAttribute(key, value.toString())\n          }\n        }\n      }\n    }\n    if (children) {\n      for (const childOuter of children) {\n        let cc = Array.isArray(childOuter) ? [...childOuter] : [childOuter]\n        for (let child of cc) {\n          if (child) {\n            if (child !== false && child != null) {\n              if (typeof child !== \"object\") {\n                el.appendChild(\n                  context.document.createTextNode(child.toString())\n                )\n              } else {\n                el.appendChild(child)\n              }\n            }\n          }\n        }\n      }\n    }\n    return el\n  }\n}\n\nexport function hArgumentParser(tag: any, attrs: any, ...children: any[]) {\n  if (typeof tag === \"object\") {\n    tag = \"fragment\"\n    children = tag.children\n    attrs = tag.attrs\n  }\n  if (Array.isArray(attrs)) {\n    children = [attrs]\n    attrs = {}\n  } else if (attrs) {\n    if (attrs.attrs) {\n      attrs = { ...attrs.attrs, ...attrs }\n      delete attrs.attrs\n    }\n  } else {\n    attrs = {}\n  }\n  return {\n    tag,\n    attrs,\n    children:\n      typeof children[0] === \"string\" ? children : children.flat(Infinity),\n  }\n}\n\nexport function hFactory(context: Context) {\n  // let context = { document }\n  context.h = function h(itag: any, iattrs: any, ...ichildren: any[]) {\n    let { tag, attrs, children } = hArgumentParser(itag, iattrs, ichildren)\n    return _h(context, tag, attrs, children)\n  }\n  return context.h\n}\n","import { decode } from \"./encoding-he\"\n\nexport const escapeHTML = (text: string) =>\n  text\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/'/g, \"&apos;\")\n    .replace(/\"/g, \"&quot;\")\n\n// encode(text, {\n//   useNamedReferences: true,\n// })\n\nexport const unescapeHTML = (html: string) => decode(html)\n","// Copyright (c) 2020 Dirk Holtwick. All rights reserved. https://holtwick.de/copyright\n\n// Special cases:\n// 1. <noop> is an element that is not printed out, can be used to create a list of elements\n// 2. Attribute name '__' gets transformed to ':' for namespace emulation\n// 3. Emulate CDATA by <cdata> element\n\nimport { hArgumentParser } from \"./h\"\nimport { escapeHTML } from \"./encoding\"\n\nexport const SELF_CLOSING_TAGS = [\n  \"area\",\n  \"base\",\n  \"br\",\n  \"col\",\n  \"embed\",\n  \"hr\",\n  \"img\",\n  \"input\",\n  \"keygen\",\n  \"link\",\n  \"meta\",\n  \"param\",\n  \"source\",\n  \"track\",\n  \"wbr\",\n  \"command\",\n]\n\nexport const CDATA = (s: string) => \"<![CDATA[\" + s + \"]]>\"\nexport const HTML = (s: string) => s\n\n// export function prependXMLIdentifier(s) {\n//   return '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n' + s\n// }\n\n// https://reactjs.org/docs/jsx-in-depth.html\nexport function markup(\n  xmlMode: boolean,\n  tag: string,\n  attrs: any = {},\n  children?: any[] | string\n) {\n  const hasChildren = !(\n    (typeof children === \"string\" && children === \"\") ||\n    (Array.isArray(children) &&\n      (children.length === 0 ||\n        (children.length === 1 && children[0] === \"\"))) ||\n    children == null\n  )\n\n  let parts: string[] = []\n  tag = tag.replace(/__/g, \":\")\n\n  // React fragment <>...</> and ours: <noop>...</noop>\n  if (tag !== \"noop\" && tag !== \"\") {\n    if (tag !== \"cdata\") {\n      parts.push(`<${tag}`)\n    } else {\n      parts.push(\"<![CDATA[\")\n    }\n\n    // Add attributes\n    for (let name in attrs) {\n      if (name && attrs.hasOwnProperty(name)) {\n        let v = attrs[name]\n        if (name === \"html\") {\n          continue\n        }\n        if (name.toLowerCase() === \"classname\") {\n          name = \"class\"\n        }\n        name = name.replace(/__/g, \":\")\n        if (v === true) {\n          // s.push( ` ${name}=\"${name}\"`)\n          parts.push(` ${name}`)\n        } else if (name === \"style\" && typeof v === \"object\") {\n          parts.push(\n            ` ${name}=\"${Object.keys(v)\n              .filter((k) => v[k] != null)\n              .map((k) => {\n                let vv = v[k]\n                vv = typeof vv === \"number\" ? vv + \"px\" : vv\n                return `${k\n                  .replace(/([a-z])([A-Z])/g, \"$1-$2\")\n                  .toLowerCase()}:${vv}`\n              })\n              .join(\";\")}\"`\n          )\n        } else if (v !== false && v != null) {\n          parts.push(` ${name}=\"${escapeHTML(v.toString())}\"`)\n        }\n      }\n    }\n\n    if (tag !== \"cdata\") {\n      if (xmlMode && !hasChildren) {\n        parts.push(\" />\")\n        return parts.join(\"\")\n      } else {\n        parts.push(\">\")\n      }\n    }\n\n    if (!xmlMode && SELF_CLOSING_TAGS.includes(tag)) {\n      return parts.join(\"\")\n    }\n  }\n\n  // Append children\n  if (hasChildren) {\n    if (typeof children === \"string\") {\n      parts.push(children)\n    } else if (children && children.length > 0) {\n      for (let child of children) {\n        if (child != null && child !== false) {\n          if (!Array.isArray(child)) {\n            child = [child]\n          }\n          for (let c of child) {\n            // todo: this fails if textContent starts with `<` and ends with `>`\n            if (\n              (c.startsWith(\"<\") && c.endsWith(\">\")) ||\n              tag === \"script\" ||\n              tag === \"style\"\n            ) {\n              parts.push(c)\n            } else {\n              parts.push(escapeHTML(c.toString()))\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (attrs.html) {\n    parts.push(attrs.html)\n  }\n\n  if (tag !== \"noop\" && tag !== \"\") {\n    if (tag !== \"cdata\") {\n      parts.push(`</${tag}>`)\n    } else {\n      parts.push(\"]]>\")\n    }\n  }\n  return parts.join(\"\")\n}\n\nexport function html(itag: string, iattrs?: object, ...ichildren: any[]) {\n  let { tag, attrs, children } = hArgumentParser(itag, iattrs, ichildren)\n  return markup(false, tag, attrs, children)\n}\n\nexport const htmlVDOM = markup.bind(null, false)\n\nhtml.firstLine = \"<!DOCTYPE html>\"\nhtml.html = true\n\nexport let h = html\n"],"mappings":"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","names":[]}