import {
  CDATA,
  SELF_CLOSING_TAGS,
  escapeHTML,
  hArgumentParser,
  hFactory,
  html,
  htmlVDOM,
  markup,
  unescapeHTML
} from "./chunk-B6CCJBSJ.js";

// src/vcss.ts
import { parse } from "css-what";
var cache = {};
function parseSelector(selector) {
  let ast = cache[selector];
  if (ast == null) {
    ast = parse(selector);
    cache[selector] = ast;
  }
  return ast;
}
function matchSelector(selector, element, { debug = false } = {}) {
  for (let rules of parseSelector(selector)) {
    if (debug) {
      console.log("Selector:", selector);
      console.log("Rules:", rules);
      console.log("Element:", element);
    }
    const handleRules = (element2, rules2) => {
      var _a, _b, _c;
      let success = false;
      for (let part of rules2) {
        const { type, name, action, value, ignoreCase = true, data } = part;
        if (type === "attribute") {
          if (action === "equals") {
            success = element2.getAttribute(name) === value;
            if (debug)
              console.log("Attribute equals", success);
          } else if (action === "start") {
            success = !!((_a = element2.getAttribute(name)) == null ? void 0 : _a.startsWith(value));
            if (debug)
              console.log("Attribute start", success);
          } else if (action === "end") {
            success = !!((_b = element2.getAttribute(name)) == null ? void 0 : _b.endsWith(value));
            if (debug)
              console.log("Attribute start", success);
          } else if (action === "element") {
            if (name === "class") {
              success = element2.classList.contains(value);
              if (debug)
                console.log("Attribute class", success);
            } else {
              success = !!((_c = element2.getAttribute(name)) == null ? void 0 : _c.includes(value));
              if (debug)
                console.log("Attribute element", success);
            }
          } else if (action === "exists") {
            success = element2.hasAttribute(name);
            if (debug)
              console.log("Attribute exists", success);
          } else {
            console.warn("Unknown CSS selector action", action);
          }
        } else if (type === "tag") {
          success = element2.tagName === name.toUpperCase();
          if (debug)
            console.log("Is tag", success);
        } else if (type === "universal") {
          success = true;
          if (debug)
            console.log("Is universal", success);
        } else if (type === "pseudo") {
          if (name === "not") {
            let ok = true;
            data.forEach((rules3) => {
              if (!handleRules(element2, rules3)) {
                ok = false;
              }
            });
            success = !ok;
          }
          if (debug)
            console.log("Is :not", success);
        } else {
          console.warn("Unknown CSS selector type", type, selector, rules2);
        }
        if (!success)
          break;
      }
      return success;
    };
    if (handleRules(element, rules)) {
      return true;
    }
  }
  return false;
}

// src/vdom.ts
var inspect = Symbol.for("nodejs.util.inspect.custom");
var B = { fontWeight: "bold" };
var I = { fontStyle: "italic" };
var M = { backgroundColor: "rgb(255, 250, 165)" };
var U = { textDecorations: "underline" };
var S = { textDecorations: "line-through" };
var DEFAULTS = {
  b: B,
  strong: B,
  em: I,
  i: I,
  mark: M,
  u: U,
  a: U,
  s: S,
  del: S,
  ins: M,
  strike: S
};
var toCamelCase = (s) => s.toLowerCase().replace(/[^a-zA-Z0-9]+(.)/g, (m, chr) => chr.toUpperCase());
var _VNode = class {
  constructor() {
    this.append = this.appendChild;
    this._parentNode = null;
    this._childNodes = [];
  }
  get nodeType() {
    console.error("Subclasses should define nodeType!");
    return 0;
  }
  get nodeName() {
    console.error("Subclasses should define nodeName!");
    return "";
  }
  get nodeValue() {
    return null;
  }
  cloneNode(deep = false) {
    let node = new this.constructor();
    if (deep) {
      node._childNodes = this._childNodes.map((c) => c.cloneNode(true));
      node._fixChildNodesParent();
    }
    return node;
  }
  _fixChildNodesParent() {
    this._childNodes.forEach((node) => node._parentNode = this);
  }
  insertBefore(newNode, node) {
    if (newNode !== node) {
      let index = node ? this._childNodes.indexOf(node) : 0;
      if (index < 0)
        index = 0;
      this._childNodes.splice(index, 0, newNode);
      this._fixChildNodesParent();
    }
  }
  appendChild(node) {
    if (node == null)
      return;
    if (node === this) {
      console.warn("Cannot appendChild to self");
      return;
    }
    if (node instanceof VDocument) {
      console.warn("No defined how to append a document to a node!", node);
    }
    if (node instanceof VDocumentFragment) {
      for (let c of [...node._childNodes]) {
        this.appendChild(c);
      }
    } else if (Array.isArray(node)) {
      for (let c of [...node]) {
        this.appendChild(c);
      }
    } else if (node instanceof _VNode) {
      node.remove();
      this._childNodes.push(node);
    } else {
      try {
        const text = typeof node === "string" ? node : JSON.stringify(node, null, 2);
        this._childNodes.push(new VTextNode(text));
      } catch (err) {
        console.error(
          `The data ${node} to be added to ${this.render()} is problematic: ${err}`
        );
      }
    }
    this._fixChildNodesParent();
  }
  removeChild(node) {
    let i = this._childNodes.indexOf(node);
    if (i >= 0) {
      node._parentNode = null;
      this._childNodes.splice(i, 1);
      this._fixChildNodesParent();
    }
  }
  remove() {
    var _a;
    (_a = this == null ? void 0 : this.parentNode) == null ? void 0 : _a.removeChild(this);
    return this;
  }
  replaceChildren(...nodes) {
    this._childNodes = nodes.map(
      (n) => typeof n === "string" ? new VTextNode(n) : n.remove()
    );
    this._fixChildNodesParent();
  }
  replaceWith(...nodes) {
    let p = this._parentNode;
    if (p) {
      let index = this._indexInParent();
      if (index >= 0) {
        nodes = nodes.map(
          (n) => typeof n === "string" ? new VTextNode(n) : n.remove()
        );
        p._childNodes.splice(index, 1, ...nodes);
        this._parentNode = null;
        p._fixChildNodesParent();
      }
    }
  }
  _indexInParent() {
    if (this._parentNode) {
      return this._parentNode.childNodes.indexOf(this);
    }
    return -1;
  }
  get parentNode() {
    return this._parentNode;
  }
  get childNodes() {
    return this._childNodes || [];
  }
  get children() {
    return this._childNodes || [];
  }
  get firstChild() {
    return this._childNodes[0];
  }
  get lastChild() {
    return this._childNodes[this._childNodes.length - 1];
  }
  get nextSibling() {
    let i = this._indexInParent();
    if (i != null) {
      return this.parentNode.childNodes[i + 1] || null;
    }
    return null;
  }
  get previousSibling() {
    let i = this._indexInParent();
    if (i > 0) {
      return this.parentNode.childNodes[i - 1] || null;
    }
    return null;
  }
  flatten() {
    let elements = [];
    if (this instanceof VElement) {
      elements.push(this);
    }
    for (let child of this._childNodes) {
      elements.push(...child.flatten());
    }
    return elements;
  }
  flattenNodes() {
    let nodes = [];
    nodes.push(this);
    for (let child of this._childNodes) {
      nodes.push(...child.flattenNodes());
    }
    return nodes;
  }
  render() {
    return "";
  }
  get textContent() {
    return this._childNodes.map((c) => c.textContent).join("");
  }
  set textContent(text) {
    this._childNodes = [];
    if (text) {
      this.appendChild(new VTextNode(text.toString()));
    }
  }
  contains(otherNode) {
    if (otherNode === this)
      return true;
    return this._childNodes.some((n) => n.contains(otherNode));
  }
  get ownerDocument() {
    var _a;
    if (this.nodeType === _VNode.DOCUMENT_NODE || this.nodeType === _VNode.DOCUMENT_FRAGMENT_NODE) {
      return this;
    }
    return (_a = this == null ? void 0 : this._parentNode) == null ? void 0 : _a.ownerDocument;
  }
  toString() {
    return `${this.nodeName}`;
  }
  [inspect]() {
    return `${this.constructor.name} "${this.render()}"`;
  }
};
var VNode = _VNode;
VNode.ELEMENT_NODE = 1;
VNode.TEXT_NODE = 3;
VNode.CDATA_SECTION_NODE = 4;
VNode.PROCESSING_INSTRUCTION_NODE = 7;
VNode.COMMENT_NODE = 8;
VNode.DOCUMENT_NODE = 9;
VNode.DOCUMENT_TYPE_NODE = 10;
VNode.DOCUMENT_FRAGMENT_NODE = 11;
var VTextNode = class extends VNode {
  constructor(text = "") {
    super();
    this._text = text;
  }
  get nodeType() {
    return VNode.TEXT_NODE;
  }
  get nodeName() {
    return "#text";
  }
  get nodeValue() {
    return this._text || "";
  }
  get textContent() {
    return this.nodeValue;
  }
  render() {
    var _a;
    const parentTagName = (_a = this.parentNode) == null ? void 0 : _a.tagName;
    if (parentTagName === "SCRIPT" || parentTagName === "STYLE") {
      return this._text;
    }
    return escapeHTML(this._text);
  }
  cloneNode(deep = false) {
    let node = super.cloneNode(deep);
    node._text = this._text;
    return node;
  }
};
var VNodeQuery = class extends VNode {
  getElementById(name) {
    return this.flatten().find((e) => e._attributes["id"] === name);
  }
  getElementsByClassName(name) {
    return this.flatten().filter((e) => e.classList.contains(name));
  }
  matches(selector) {
    return matchSelector(selector, this);
  }
  querySelectorAll(selector) {
    return this.flatten().filter((e) => e.matches(selector));
  }
  querySelector(selector) {
    return this.flatten().find((e) => e.matches(selector));
  }
  parent(selector) {
    var _a;
    if (this.matches(selector)) {
      return this;
    }
    if (this.parentNode == null) {
      return null;
    }
    return (_a = this.parentNode) == null ? void 0 : _a.parent(selector);
  }
  handle(selector, handler) {
    let i = 0;
    for (let el of this.querySelectorAll(selector)) {
      handler(el, i++);
    }
  }
};
var VElement = class extends VNodeQuery {
  constructor(name = "div", attrs = {}) {
    super();
    this._originalTagName = name;
    this._nodeName = (name || "").toUpperCase();
    this._attributes = attrs || {};
    this._styles = null;
  }
  get nodeType() {
    return VNode.ELEMENT_NODE;
  }
  get nodeName() {
    return this._nodeName;
  }
  cloneNode(deep = false) {
    let node = super.cloneNode(deep);
    node._originalTagName = this._originalTagName;
    node._nodeName = this._nodeName;
    node._attributes = Object.assign({}, this._attributes);
    return node;
  }
  get attributes() {
    return this._attributes;
  }
  _findAttributeName(name) {
    const search = name.toLowerCase();
    return Object.keys(this._attributes).find(
      (name2) => search === name2.toLowerCase()
    ) || null;
  }
  setAttribute(name, value) {
    this.removeAttribute(name);
    this._attributes[name] = value;
    this._styles = null;
  }
  getAttribute(name) {
    const originalName = this._findAttributeName(name);
    return originalName ? this._attributes[originalName] : null;
  }
  removeAttribute(name) {
    const originalName = this._findAttributeName(String(name));
    if (originalName) {
      delete this._attributes[name];
    }
  }
  hasAttribute(name) {
    const originalName = this._findAttributeName(name);
    return originalName ? this._attributes[originalName] != null : false;
  }
  get style() {
    if (this._styles == null) {
      let styles = Object.assign({}, DEFAULTS[this.tagName.toLowerCase()] || {});
      let styleString = this.getAttribute("style");
      if (styleString) {
        let m;
        let re = /\s*([\w-]+)\s*:\s*([^;]+)/g;
        while (m = re.exec(styleString)) {
          let name = m[1];
          let value = m[2].trim();
          styles[name] = value;
          styles[toCamelCase(name)] = value;
        }
      }
      this._styles = styles;
    }
    return this._styles;
  }
  get tagName() {
    return this._nodeName;
  }
  get id() {
    return this._attributes.id || null;
  }
  set id(value) {
    if (value == null)
      delete this._attributes.id;
    else
      this._attributes.id = value;
  }
  get src() {
    return this._attributes.src;
  }
  set src(value) {
    if (value == null)
      delete this._attributes.src;
    else
      this._attributes.src = value;
  }
  getElementsByTagName(name) {
    name = name.toUpperCase();
    let elements = this.flatten();
    if (name !== "*") {
      return elements.filter((e) => e.tagName === name);
    }
    return elements;
  }
  setInnerHTML(html2) {
    throw "setInnerHTML is not implemented; see vdomparser for an example";
  }
  get innerHTML() {
    return this._childNodes.map((c) => c.render(html)).join("");
  }
  set innerHTML(html2) {
    this.setInnerHTML(html2);
  }
  get outerHTML() {
    return this.render(htmlVDOM);
  }
  get className() {
    return this._attributes["class"] || "";
  }
  set className(name) {
    if (Array.isArray(name)) {
      name = name.filter((n) => !!n).join(" ");
    } else if (typeof name === "object") {
      name = Object.entries(name).filter(([k, v]) => !!v).map(([k, v]) => k).join(" ");
    }
    this._attributes["class"] = name;
  }
  get classList() {
    let self = this;
    let classNames = (this.className || "").trim().split(/\s+/g) || [];
    return {
      contains(s) {
        return classNames.includes(s);
      },
      add(s) {
        if (!classNames.includes(s)) {
          classNames.push(s);
          self.className = classNames;
        }
      },
      remove(s) {
        let index = classNames.indexOf(s);
        if (index >= 0) {
          classNames.splice(index, 1);
          self.className = classNames;
        }
      }
    };
  }
  render(h2 = htmlVDOM) {
    return h2(
      this._originalTagName || this.tagName,
      this.attributes,
      this._childNodes.map((c) => c.render(h2)).join("")
    );
  }
};
var VDocType = class extends VNode {
  get nodeName() {
    return super.nodeName;
  }
  get nodeValue() {
    return super.nodeValue;
  }
  get nodeType() {
    return VDocType.DOCUMENT_TYPE_NODE;
  }
  render() {
    return `<!DOCTYPE html>`;
  }
};
var VDocumentFragment = class extends VNodeQuery {
  get nodeType() {
    return VNode.DOCUMENT_FRAGMENT_NODE;
  }
  get nodeName() {
    return "#document-fragment";
  }
  render(h2 = htmlVDOM) {
    return this._childNodes.map((c) => c.render(h2) || []).join("");
  }
  get innerHTML() {
    return this._childNodes.map((c) => c.render(html)).join("");
  }
  createElement(name, attrs = {}) {
    return new VElement(name, attrs);
  }
  createDocumentFragment() {
    return new VDocumentFragment();
  }
  createTextNode(text) {
    return new VTextNode(text);
  }
};
var VDocument = class extends VDocumentFragment {
  get nodeType() {
    return VNode.DOCUMENT_NODE;
  }
  get nodeName() {
    return "#document";
  }
  get documentElement() {
    return this.firstChild;
  }
  render(h2 = htmlVDOM) {
    let content = super.render(h2);
    if (this.docType) {
      content = this.docType.render() + content;
    }
    return content;
  }
};
var VHTMLDocument = class extends VDocument {
  constructor(empty = false) {
    super();
    this.docType = new VDocType();
    if (!empty) {
      let html2 = new VElement("html");
      let body = new VElement("body");
      let head = new VElement("head");
      let title = new VElement("title");
      html2.appendChild(head);
      head.appendChild(title);
      html2.appendChild(body);
      this.appendChild(html2);
    }
  }
  get body() {
    let body = this.querySelector("body");
    if (!body) {
      let html2 = this.querySelector("html");
      if (!html2) {
        html2 = new VElement("html");
        this.appendChild(html2);
      }
      body = new VElement("body");
      html2.appendChild(html2);
    }
    return body;
  }
  get title() {
    var _a;
    return ((_a = this.querySelector("title")) == null ? void 0 : _a.textContent) || "";
  }
  set title(title) {
    const titleElement = this.querySelector("title");
    if (titleElement)
      titleElement.textContent = title;
  }
  get head() {
    let head = this.querySelector("head");
    if (!head) {
      let html2 = this.querySelector("html");
      if (!html2) {
        html2 = new VElement("html");
        this.appendChild(html2);
      }
      head = new VElement("head");
      html2.insertBefore(html2);
    }
    return head;
  }
};
function createDocument() {
  return new VDocument();
}
function createHTMLDocument() {
  return new VHTMLDocument();
}
var document = createDocument();
var h = hFactory({ document });

// src/utils.ts
function removeBodyContainer(body) {
  let ehead = body.querySelector("head");
  let ebody = body.querySelector("body");
  if (ebody || ehead) {
    let body2 = new VDocumentFragment();
    ehead && body2.appendChild(ehead.childNodes);
    ebody && body2.appendChild(ebody.children);
    return body2;
  }
  return body;
}

// src/htmlparser.ts
var attrRe = /([^=\s]+)(\s*=\s*(("([^"]*)")|('([^']*)')|[^>\s]+))?/gm;
var endTagRe = /^<\/([^>\s]+)[^>]*>/m;
var startTagRe = /^<([^>\s\/]+)((\s+[^=>\s]+(\s*=\s*(("[^"]*")|('[^']*')|[^>\s]+))?)*)\s*\/?\s*>/m;
var selfCloseTagRe = /\s*\/\s*>\s*$/m;
var HtmlParser = class {
  constructor(options) {
    this.attrRe = attrRe;
    this.endTagRe = endTagRe;
    this.startTagRe = startTagRe;
    this.defaults = { ignoreWhitespaceText: false };
    options = options || {};
    if (options.scanner) {
      this.scanner = options.scanner;
      options.scanner = null;
    }
    this.options = Object.assign({}, this.defaults, options);
  }
  parse(html2) {
    let treatAsChars = false;
    let index, match, characters;
    while (html2.length) {
      if (html2.substring(0, 4) === "<!--") {
        index = html2.indexOf("-->");
        if (index !== -1) {
          this.scanner.comment(html2.substring(4, index));
          html2 = html2.substring(index + 3);
          treatAsChars = false;
        } else {
          treatAsChars = true;
        }
      } else if (html2.substring(0, 2) === "</") {
        match = this.endTagRe.exec(html2);
        if (match) {
          html2 = RegExp.rightContext;
          treatAsChars = false;
          this.parseEndTag(RegExp.lastMatch, match[1]);
        } else {
          treatAsChars = true;
        }
      } else if (html2.charAt(0) === "<") {
        match = this.startTagRe.exec(html2);
        if (match) {
          html2 = RegExp.rightContext;
          treatAsChars = false;
          this.parseStartTag(RegExp.lastMatch, match[1], match);
        } else {
          treatAsChars = true;
        }
      }
      if (treatAsChars) {
        index = html2.indexOf("<");
        if (index === 0) {
          index = html2.substring(1).indexOf("<");
        }
        if (index === -1) {
          characters = html2;
          html2 = "";
        } else {
          characters = html2.substring(0, index);
          html2 = html2.substring(index);
        }
        if (!this.options.ignoreWhitespaceText || !/^\s*$/.test(characters)) {
          this.scanner.characters(characters);
        }
      }
      treatAsChars = true;
      match = null;
    }
  }
  parseStartTag(input, tagName, match) {
    const isSelfColse = selfCloseTagRe.test(input);
    let attrInput = match[2];
    if (isSelfColse) {
      attrInput = attrInput.replace(/\s*\/\s*$/, "");
    }
    const attrs = this.parseAttributes(tagName, attrInput);
    this.scanner.startElement(tagName, attrs, isSelfColse, match[0]);
  }
  parseEndTag(input, tagName) {
    this.scanner.endElement(tagName);
  }
  parseAttributes(tagName, input) {
    const attrs = {};
    input.replace(
      this.attrRe,
      (attr, name, c2, value, c4, valueInQuote, c6, valueInSingleQuote) => {
        attrs[name] = valueInSingleQuote ?? valueInQuote ?? value ?? true;
      }
    );
    return attrs;
  }
};

// src/vdomparser.ts
function vdom(obj = null) {
  if (obj instanceof VNode) {
    return obj;
  }
  if (obj instanceof Buffer) {
    obj = obj.toString("utf-8");
  }
  if (typeof obj === "string") {
    return parseHTML(obj);
  }
  return new VDocumentFragment();
}
function parseHTML(html2) {
  if (typeof html2 !== "string") {
    console.error("parseHTML requires string, found", html2);
    throw new Error("parseHTML requires string");
  }
  let frag = html2.indexOf("<!") === 0 ? new VHTMLDocument(true) : new VDocumentFragment();
  let stack = [frag];
  let parser = new HtmlParser({
    scanner: {
      startElement(tagName, attrs, isSelfClosing) {
        const lowerTagName = tagName.toLowerCase();
        if (lowerTagName === "!doctype") {
          frag.docType = new VDocType();
          return;
        }
        for (let name in attrs) {
          if (attrs.hasOwnProperty(name)) {
            let value = attrs[name];
            if (typeof value === "string") {
              attrs[name] = unescapeHTML(value);
            }
          }
        }
        let parentNode = stack[stack.length - 1];
        if (parentNode) {
          const element = document.createElement(tagName, attrs);
          parentNode.appendChild(element);
          if (!(SELF_CLOSING_TAGS.includes(tagName.toLowerCase()) || isSelfClosing)) {
            stack.push(element);
          }
        }
      },
      endElement(tagName) {
        stack.pop();
      },
      characters(text) {
        var _a;
        text = unescapeHTML(text);
        let parentNode = stack[stack.length - 1];
        if (((_a = parentNode == null ? void 0 : parentNode.lastChild) == null ? void 0 : _a.nodeType) === VNode.TEXT_NODE) {
          parentNode.lastChild._text += text;
        } else {
          if (parentNode) {
            parentNode.appendChild(new VTextNode(text));
          }
        }
      },
      comment(text) {
      }
    }
  });
  parser.parse(html2);
  return frag;
}
VElement.prototype.setInnerHTML = function(html2) {
  let frag = parseHTML(html2);
  this._childNodes = frag._childNodes;
  this._fixChildNodesParent();
};

// src/tidy.ts
var SELECTOR_BLOCK_ELEMENTS = "meta,link,script,p,h1,h2,h3,h4,h5,h6,blockquote,div,ul,ol,li,article,section,footer,head,body,title,nav,section,article,hr,form";
var TAGS_KEEP_CONTENT = ["PRE", "CODE", "SCRIPT", "STYLE", "TT"];
function level(element) {
  let indent = "";
  while (element.parentNode) {
    indent += "  ";
    element = element.parentNode;
  }
  return indent.substr(2);
}
function tidyDOM(document2) {
  document2.handle(SELECTOR_BLOCK_ELEMENTS, (e) => {
    var _a, _b, _c, _d, _e, _f;
    let ee = e;
    while (ee) {
      if (TAGS_KEEP_CONTENT.includes(ee.tagName))
        return;
      ee = ee.parentNode;
    }
    let prev = e.previousSibling;
    if (!prev || prev.nodeType !== VNode.TEXT_NODE || !((_a = prev.nodeValue) == null ? void 0 : _a.endsWith("\n"))) {
      (_b = e.parentNode) == null ? void 0 : _b.insertBefore(new VTextNode("\n"), e);
    }
    (_c = e.parentNode) == null ? void 0 : _c.insertBefore(new VTextNode(level(e)), e);
    let next = e.nextSibling;
    if (!next || next.nodeType !== VNode.TEXT_NODE || !((_d = next.nodeValue) == null ? void 0 : _d.startsWith("\n"))) {
      if (next) {
        (_e = e.parentNode) == null ? void 0 : _e.insertBefore(new VTextNode("\n"), next);
      } else {
        (_f = e.parentNode) == null ? void 0 : _f.appendChild(new VTextNode("\n"));
      }
    }
    if (e.childNodes.length) {
      let first = e.firstChild;
      if (first.nodeType === VNode.TEXT_NODE) {
        e.insertBefore(new VTextNode("\n" + level(e) + "  "));
      }
      e.appendChild(new VTextNode("\n" + level(e)));
    }
  });
}

// src/xml.ts
function xml(itag, iattrs, ...ichildren) {
  let { tag, attrs, children } = hArgumentParser(itag, iattrs, ichildren);
  return markup(true, tag, attrs, children);
}
xml.firstLine = '<?xml version="1.0" encoding="utf-8"?>';
xml.xml = true;
export {
  CDATA,
  VDocType,
  VDocument,
  VDocumentFragment,
  VElement,
  VHTMLDocument,
  VNode,
  VNodeQuery,
  VTextNode,
  createDocument,
  createHTMLDocument,
  document,
  escapeHTML,
  h,
  hArgumentParser,
  hFactory,
  html,
  parseHTML,
  removeBodyContainer,
  tidyDOM,
  unescapeHTML,
  vdom,
  xml
};
//# sourceMappingURL=index.js.map